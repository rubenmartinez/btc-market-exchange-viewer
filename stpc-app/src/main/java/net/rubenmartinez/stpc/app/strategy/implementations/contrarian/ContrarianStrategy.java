// Generated by delombok at Sat Dec 15 18:24:59 CET 2018
package net.rubenmartinez.stpc.app.strategy.implementations.contrarian;

import java.math.BigDecimal;
import java.util.List;
import java.util.ListIterator;
import java.util.Optional;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import net.rubenmartinez.stpc.app.exchange.decorator.SimulatedTradesExchangeClient;
import net.rubenmartinez.stpc.app.strategy.ReconfigurableReevaluatingStrategy;
import net.rubenmartinez.stpc.app.strategy.StrategyType;
import net.rubenmartinez.stpc.app.strategy.service.exception.StrategyException;
import net.rubenmartinez.stpc.exchange.domain.OrderSide;
import net.rubenmartinez.stpc.exchange.domain.Trade;
import net.rubenmartinez.stpc.exchange.listener.TradeListener;

/**
 * ContrarianStrategy as requested in the challenge
 * 
 * This Strategy will do both:
 * <ul>
 *   <li>Simulate trades based on new live trades as this is a {@link TradeListener}</li>
 *   <li>Re-evaluate (and simulate) past trades when requested via method {@link ReconfigurableReevaluatingStrategy#reevaluatePastTrades(int)} is called or
 *   in a {@link ReconfigurableReevaluatingStrategy#reconfigure(Object)}
 *   if {@link ContrarianStrategyConfig#isReevaluateTradesOnReconfiguration()} is true</li>
 * </ul>
 * 
 * To be honest, when I read the challenge description I thought the Strategy should simulate trades only based on new lives trades.
 * It wasn't till the last day (that I had booked to write documentation and more tests) when I realized just by the last row in the checklist table that the strategy should be able also
 * to reevaluate past trades, so I had to re-write part of the code at the last minute
 */
@StrategyType("contrarian")
public class ContrarianStrategy implements ReconfigurableReevaluatingStrategy<ContrarianStrategyConfig>, TradeListener {
	private static final Logger LOGGER = LoggerFactory.getLogger(ContrarianStrategy.class);
	private static final int REEVALUATING_TIMEOUT_SECONDS = 10;
	private SimulatedTradesExchangeClient simulatedTradesExchangeClient;
	private String strategyId;
	private boolean activated;
	private BigDecimal lastTradePrice;
	private OrderSide lastTradeMakerSide;
	private ContrarianStrategyStats stats;
	private volatile CountDownLatch strategyRevaluatingLatch;
	private volatile ContrarianStrategyConfig config;

	public ContrarianStrategy(String id, ContrarianStrategyConfig config, SimulatedTradesExchangeClient exchangeClient) {
		this.strategyId = id;
		validateConfig(config);
		this.config = config;
		this.simulatedTradesExchangeClient = exchangeClient;
		this.activated = false;
		this.stats = new ContrarianStrategyStats();
	}

	@Override
	// If having more strategy types, a refactoring would be needed to move some common logic to a base class
	public void reevaluatePastTrades(int n) {
		try {
			strategyRevaluatingLatch = new CountDownLatch(1); // This will pause evaluating live trades
			
			simulatedTradesExchangeClient.clearSimulatedTrades(strategyId);
			stats.reset();
			
			LOGGER.debug("Reevaluating {} trades", n);
			List<Trade> trades = simulatedTradesExchangeClient.getLastTrades(n);
			ListIterator<Trade> tradesIterator = trades.listIterator(trades.size());
			
			Trade oldestTradeFromReevaluation = tradesIterator.previous();

			lastTradeMakerSide = oldestTradeFromReevaluation.getMakerSide();
			lastTradePrice = new BigDecimal(oldestTradeFromReevaluation.getPrice());
			
			forEachReverse(tradesIterator, this::processTrade);
			
			LOGGER.debug("{} trades re-evaluated", trades.size());
		} finally {
			strategyRevaluatingLatch.countDown();
		}
	}

	@Override
	public void reconfigure(ContrarianStrategyConfig config) {
		validateConfig(config);
		this.config = config;
		if (config.isReevaluateTradesOnReconfiguration()) {
			reevaluatePastTrades(config.getPastTradeToEvaluate());
		}
	}

	@Override
	public Class<ContrarianStrategyConfig> getConfigType() {
		return ContrarianStrategyConfig.class;
	}

	@Override
	public ContrarianStrategyConfig getConfig() {
		return config;
	}

	@Override
	public void activate() {
		synchronized (this) {
			if (!activated) {
				simulatedTradesExchangeClient.addTradeListener(this);
				reevaluatePastTrades(config.getPastTradeToEvaluate());
				activated = true;
			} else {
				LOGGER.warn("Already activated");
			}
		}
	}

	@Override
	public void deactivate() {
		synchronized (this) {
			if (activated) {
				simulatedTradesExchangeClient.removeTradeListener(this);
				activated = false;
			} else {
				LOGGER.warn("Already deactivated");
			}
		}
	}

	private void processTrade(Trade trade) {
		LOGGER.trace("processTrade: {}", trade);
		updateStats(trade);
		executeStrategy(trade);
		stats.incTradesProcessed();
	}

	@Override
	public void onNewTrade(Trade trade) {
		LOGGER.trace("onNewTrade (strategy enabled: [{}]): {}", activated, trade);
		if (activated) {
			checkStrategyReadyForLiveTrades();
			processTrade(trade);
		} else {
			LOGGER.info("{} disabled", strategyId);
		}
	}

	private void updateStats(Trade lastTrade) {
		BigDecimal price = new BigDecimal(lastTrade.getPrice());
		
		if (price.compareTo(lastTradePrice) < 0) {
			stats.incCurrentConsecutiveDownticks();
			stats.setCurrentConsecutiveUpticks(0);
			stats.setCurrentConsecutiveZeroticks(0);
			LOGGER.info("Registered downtick");
		} else if (price.compareTo(lastTradePrice) > 0) {
			stats.incCurrentConsecutiveUpticks();
			stats.setCurrentConsecutiveZeroticks(0);
			stats.setCurrentConsecutiveDownticks(0);
			LOGGER.info("Registered uptick");
		} else {
			stats.incCurrentConsecutiveZeroticks();
			LOGGER.info("Registered zerotick");
		}
		
		LOGGER.info("consecutive upticks: [{}]; consecutive downticks: [{}]; consecutive zeroticks: [{}]; previous price: [{}], this trade price: [{}]", stats.getCurrentConsecutiveUpticks(), stats.getCurrentConsecutiveDownticks(), stats.getCurrentConsecutiveZeroticks(), lastTradePrice, price);
		lastTradePrice = price;
	}

	private void executeStrategy(Trade lastTrade) {
		if (stats.getCurrentConsecutiveZeroticks() > 0) {
			// Never trade after a zero tick
			return;
		}
		
		final ContrarianStrategyConfig configLocal = this.config; // Just copying the volatile variable into a faster local variable for reading, this will also protect this call of parallel config changes (potentially in the middle of the call)
		
		if (stats.getCurrentConsecutiveUpticks() >= configLocal.getConsecutiveUpticksToSell()) {

			String newOrderId = lastTrade.getTradeId() + "-contrarian-simulated-sell";
			simulatedTradesExchangeClient.simulateSell(strategyId, newOrderId, lastTradePrice, configLocal.getTradeAmountInBaseCurrency(), lastTrade.getCreationDate());
			LOGGER.info("Placed SELL order [{}] after {} consecutive upticks. price: [{}]", newOrderId, stats.getCurrentConsecutiveUpticks(), lastTradePrice);
			
			if (configLocal.isResetTicksAfterTrade()) {
				stats.setCurrentConsecutiveUpticks(0);
			}
			stats.incSellTradesPlaced();
			stats.addTradesBalance(lastTradePrice.multiply(configLocal.getTradeAmountInBaseCurrency()));
			stats.setLastSellPrice(Optional.of(lastTradePrice));
			lastTradeMakerSide = OrderSide.SELL;
		} else if (stats.getCurrentConsecutiveDownticks() >= configLocal.getConsecutiveDownticksToBuy()) {
			
			String newOrderId = lastTrade.getTradeId() + "-contrarian-simulated-buy";
			simulatedTradesExchangeClient.simulateBuy(strategyId, newOrderId, lastTradePrice, configLocal.getTradeAmountInBaseCurrency(), lastTrade.getCreationDate());
			LOGGER.info("Placed BUY order [{}] after {} consecutive downticks. price: [{}]", newOrderId, stats.getCurrentConsecutiveDownticks(), lastTradePrice);
			
			if (configLocal.isResetTicksAfterTrade()) {
				stats.setCurrentConsecutiveDownticks(0);
			}
			stats.incBuyTradesPlaced();
			stats.addTradesBalance(lastTradePrice.multiply(configLocal.getTradeAmountInBaseCurrency()).negate());
			stats.setLastBuyPrice(Optional.of(lastTradePrice));
			lastTradeMakerSide = OrderSide.BUY;
		}
	}

	private final void checkStrategyReadyForLiveTrades() {
		try {
			LOGGER.trace("checkStrategyReadyForLiveTrades");
			boolean ready = strategyRevaluatingLatch.await(REEVALUATING_TIMEOUT_SECONDS, TimeUnit.SECONDS);
			if (!ready) {
				throw new StrategyException("Strategy reevaluating timeout: " + REEVALUATING_TIMEOUT_SECONDS + " seconds.");
			}
			LOGGER.trace("Strategy ready for live trades");
		} catch (InterruptedException e) {
			Thread.currentThread().interrupt();
			throw new StrategyException("Interrupted while waiting for reevaluation. Aborting operation");
		}
	}

	private static final <E> void forEachReverse(ListIterator<E> listIterator, Consumer<? super E> action) {
		while (listIterator.hasPrevious()) {
			action.accept(listIterator.previous());
		}
	}

	private static void validateConfig(ContrarianStrategyConfig config) {
		if (config.getPastTradeToEvaluate() < 1) {
			throw new IllegalArgumentException("pastTradeToEvaluate must be greater than 1");
		}
		if (config.getConsecutiveDownticksToBuy() < 0) {
			throw new IllegalArgumentException("consecutiveDownticksToBuy must be greater than zero");
		}
		if (config.getConsecutiveUpticksToSell() < 0) {
			throw new IllegalArgumentException("consecutiveUpticksToSell must be greater than zero");
		}
		if (config.getTradeAmountInBaseCurrency().compareTo(BigDecimal.ZERO) < 0) {
			throw new IllegalArgumentException("tradeAmountBaseCurrency must be greater than zero");
		}
	}

	public String getStrategyId() {
		return this.strategyId;
	}

	public boolean isActivated() {
		return this.activated;
	}

	public BigDecimal getLastTradePrice() {
		return this.lastTradePrice;
	}

	public OrderSide getLastTradeMakerSide() {
		return this.lastTradeMakerSide;
	}

	public ContrarianStrategyStats getStats() {
		return this.stats;
	}
}
