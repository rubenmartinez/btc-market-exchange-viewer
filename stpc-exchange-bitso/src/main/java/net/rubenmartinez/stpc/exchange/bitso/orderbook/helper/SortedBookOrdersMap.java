// Generated by delombok at Sat Dec 15 11:30:27 CET 2018
package net.rubenmartinez.stpc.exchange.bitso.orderbook.helper;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.ConcurrentSkipListMap;
import java.util.stream.Collectors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import net.rubenmartinez.stpc.exchange.bitso.orderbook.domain.BitsoOrder;
import net.rubenmartinez.stpc.exchange.domain.Order;

/**
 * A helper class just to have the orders sorted by price, as it was difficult to find a Java library that allows sorting by a value field. Note that this id is internal and won't be exposed outside 
 * 
 * <strong>For performance reasons, this class is not meant to be fully
 * consistent between the map and the ordered list.</strong>
 * 
 * If a method name ends in <code>threadSafe</code>, it means it can be called concurrently with any other method
 * in this class (regardless if the other method is named as thread-safe or not)
 */
public class SortedBookOrdersMap {

	public enum SortOrdering {
		ASCENDING, DESCENDING;
	}

	private static final Logger LOGGER = LoggerFactory.getLogger(SortedBookOrdersMap.class);
	private ConcurrentSkipListMap<SortedOrdersKey, BitsoOrder> sortedOrdersMapByPrice;
	private HashMap<String, BitsoOrder> ordersMapById;

	public SortedBookOrdersMap(SortOrdering ordering) {
		Comparator<SortedOrdersKey> comparator = (ordering == SortOrdering.ASCENDING ? Comparator.naturalOrder() : Comparator.reverseOrder());
		this.sortedOrdersMapByPrice = new ConcurrentSkipListMap<>(comparator);
		this.ordersMapById = new HashMap<>();
	}

	/**
	 * Returns a <strong>copy</strong> of the <code>n</code> best orders stored in this map
	 * 
	 * @param n
	 * @return
	 */
	public List<Order> getBestNSortedOrdersThreadSafe(int n) {
		if (n < 0) {
			throw new IllegalArgumentException("Number of orders must be greater than zero");
		}
		LOGGER.trace("getBestNSortedOrdersThreadSafe({})", n);
		List<Order> orders = sortedOrdersMapByPrice.values().stream().limit(n).collect(Collectors.toList());
		LOGGER.trace("getBestNSortedOrdersThreadSafe({}) --> ", orders);
		return orders;
	}

	/**
	 * Returns a <strong>copy</strong> of the best orders stored in this map
	 * 
	 */
	public List<Order> getSortedOrdersThreadSafe() {
		return new ArrayList<>(sortedOrdersMapByPrice.values());
	}

	/**
	 * Returns the number of orders in this this map.  If this map
	 * contains more than {@code Integer.MAX_VALUE} elements, it
	 * returns {@code Integer.MAX_VALUE}.
	 *
	 * <p>Beware that, unlike in most collections, this method is
	 * <em>NOT</em> a constant-time operation. Because of the
	 * asynchronous nature of these maps, determining the current
	 * number of elements requires traversing them all to count them.
	 * Additionally, it is possible for the size to change during
	 * execution of this method, in which case the returned result
	 * will be inaccurate. Thus, this method is typically not very
	 * useful in concurrent applications.
	 *
	 * @return the number of elements in this map
	 */
	public int size() {
		return ordersMapById.size();
	}

	/**
	 * Maps the specified key to the specified value in this table. Neither the key
	 * nor the value can be null.
	 *
	 * <p>
	 * The value can be retrieved by calling the {@code get} method with a key that
	 * is equal to the original key.
	 * </p>
	 *
	 * @param key   key with which the specified value is to be associated
	 * @param value value to be associated with the specified key
	 * @return the previous value associated with {@code key}, or {@code null} if
	 *         there was no mapping for {@code key}
	 * @throws NullPointerException if the specified key or value is null
	 */
	public Optional<BitsoOrder> put(BitsoOrder order) {
		BitsoOrder previous = ordersMapById.put(order.getId(), order);
		sortedOrdersMapByPrice.put(getKey(order), order);
		LOGGER.trace("New order put: {}", order);
		return Optional.ofNullable(previous);
	}

	/**
	 * Removes the key (and its corresponding value) from this map.
	 * This method does nothing if the key is not in the map.
	 *
	 * @param  key the key that needs to be removed 
	 * @return the previous value associated with {@code key}, or
	 *         {@code null} if there was no mapping for {@code key}
	 * @throws NullPointerException if the specified key is null
	 */
	public Optional<BitsoOrder> remove(String orderId) {
		BitsoOrder previous = ordersMapById.remove(orderId);
		if (previous != null) {
			sortedOrdersMapByPrice.remove(getKey(previous));
		}
		LOGGER.trace("Order removed: {}", orderId);
		return Optional.ofNullable(previous);
	}

	/**
	 * Returns the value to which the specified key is mapped, or {@code null} if
	 * this map contains no mapping for the key.
	 * <p>
	 * More formally, if this map contains a mapping from a key {@code k} to a value
	 * {@code v} such that {@code key.equals(k)}, then this method returns
	 * {@code v}; otherwise it returns {@code null}. (There can be at most one such
	 * mapping.)
	 *
	 * @throws NullPointerException if the specified key is null
	 */
	public Optional<BitsoOrder> get(String orderId) {
		// As only the map is involved, this uses only the per-bin lock in ConcurrentHashMap which is more efficient that our lock
		return Optional.ofNullable(ordersMapById.get(orderId));
	}

	private static SortedOrdersKey getKey(BitsoOrder order) {
		return new SortedOrdersKey(order.getId(), new BigDecimal(order.getPrice()));
	}


	private static class SortedOrdersKey implements Comparable<SortedOrdersKey> {
		private String orderId;
		private BigDecimal price;

		/**
	     * Compares this order with another order. As per {@link Comparable} contract it returns a
	     * negative integer, zero, or a positive integer as this object is less
	     * than, equal to, or greater than the specified object.
	     * 
	     * This method is consistent with equals so:
	     * <tt>(x.compareTo(y)==0) == (x.equals(y))</tt>
	     *
	     * @param   o the order to be compared.
	     * @return  a negative integer, zero, or a positive integer as this object
	     *          is less than, equal to, or greater than the specified object.
	     *
	     * @throws NullPointerException if the specified object is null
	     * @throws ClassCastException if the specified object's type prevents it
	     *         from being compared to this object.
	     */
		@Override
		public int compareTo(SortedOrdersKey other) {
			int priceComparation = price.compareTo(other.price);
			if (priceComparation != 0) {
				return priceComparation;
			} else {
				// We need to make it consistent with equals, since SortedMaps doesn't use equals, they use compareTo
				return orderId.compareTo(other.orderId);
			}
		}

		@Override
		public int hashCode() {
			return orderId.hashCode();
		}

		@Override
		public boolean equals(Object object) {
			if (object == null || getClass() != object.getClass()) {
				return false;
			}
			return orderId.equals(((SortedOrdersKey) object).orderId);
		}

		public SortedOrdersKey(final String orderId, final BigDecimal price) {
			this.orderId = orderId;
			this.price = price;
		}

		@Override
		public String toString() {
			return "SortedBookOrdersMap.SortedOrdersKey(orderId=" + this.orderId + ", price=" + this.price + ")";
		}
	}
}
